%%
clc; clear; clf;
clear variables; close all; clc; % Take care to clear variables or else elements of L may not be overwritten correctly - maybe a Matlab optimiser problem.
%This script was used to generate the camParam values. It was autogenerated using the cameraCalibrator app
%-------------------------------------------------------

% Define images to process
imageFileNames = {'C:\Users\Dane\Desktop\Assignment_1_MTRN_4230_Photos\RealCalibration\Cal1.jpg',...
    'C:\Users\Dane\Desktop\Assignment_1_MTRN_4230_Photos\RealCalibration\Cal2.jpg',...
    'C:\Users\Dane\Desktop\Assignment_1_MTRN_4230_Photos\RealCalibration\Cal3.jpg',...
    'C:\Users\Dane\Desktop\Assignment_1_MTRN_4230_Photos\RealCalibration\Cal4.jpg',...
    'C:\Users\Dane\Desktop\Assignment_1_MTRN_4230_Photos\RealCalibration\Cal5.jpg',...
    'C:\Users\Dane\Desktop\Assignment_1_MTRN_4230_Photos\RealCalibration\Cal6.jpg',...
    'C:\Users\Dane\Desktop\Assignment_1_MTRN_4230_Photos\RealCalibration\Cal8.jpg',...
    'C:\Users\Dane\Desktop\Assignment_1_MTRN_4230_Photos\RealCalibration\Cal11.jpg',...
    'C:\Users\Dane\Desktop\Assignment_1_MTRN_4230_Photos\RealCalibration\Cal12.jpg',...
    'C:\Users\Dane\Desktop\Assignment_1_MTRN_4230_Photos\RealCalibration\Cal13.jpg',...
    'C:\Users\Dane\Desktop\Assignment_1_MTRN_4230_Photos\RealCalibration\Cal10.jpg',...
    };
% Detect checkerboards in images
[imagePoints, boardSize, imagesUsed] = detectCheckerboardPoints(imageFileNames);
imageFileNames = imageFileNames(imagesUsed);

% Read the first image to obtain image size
originalImage = imread(imageFileNames{1});
[mrows, ncols, ~] = size(originalImage);

% Generate world coordinates of the corners of the squares
squareSize = 25;  % in units of 'millimeters'
worldPoints = generateCheckerboardPoints(boardSize, squareSize);

% Calibrate the camera
[cameraParams, imagesUsed, estimationErrors] = estimateCameraParameters(imagePoints, worldPoints, ...
    'EstimateSkew', false, 'EstimateTangentialDistortion', false, ...
    'NumRadialDistortionCoefficients', 2, 'WorldUnits', 'millimeters', ...
    'InitialIntrinsicMatrix', [], 'InitialRadialDistortion', [], ...
    'ImageSize', [mrows, ncols]);
%%
clc;
%Solving for the Extrinsic Matrix

%Notation from week 3 lecture:
%Ke = [R T] = extrinsic matrix
    %R = 3x3 rotation matrix
    %T = 3x1 translation matrix 
%K = intrinsic matrix

%The intrinsic matrix was generated using the Calibration app and can be
%found using cameraParams.IntrinsicMatrix

%Ke is calculated using the function: extrinsics(imagePoints,worldPoints,cameraParams)

%Where image points is calculated using: [imagePoints,boardSize] = detectCheckerboardPoints(I)
%Where input I is the image of a (ideally) undistorted black and white
%Checkerboard larger than 4x4 squares
I = undistortImage(imread('blank_image_w_checkerAsim.jpg'),cameraParams);
[imagePoints,boardSize] = detectCheckerboardPoints(I);

%The worldpoints (corner co-ords of each checkerboard square) can then be
%calculated using: [worldPoints] = generateCheckerboardPoints(boardSize,squareSize)
%where the square size is the size of each checkerboard square in mm:

squareSize = 36.5;
worldPoints = generateCheckerboardPoints(boardSize,squareSize);
%This function outputs the world points starting from 0,0.
%Hence offsets must be applied to get the correct co-ords
worldPoints(:,2) = worldPoints(:,2) + 175 + squareSize;
worldPoints(:,1) = worldPoints(:,1) - 3.5*squareSize;
[R,t] = extrinsics(imagePoints,worldPoints,cameraParams);
% a Z coordinate must be added to the world points:
% Z = 147 (from ABB_IRB120_Setup_Data.txt)
worldPoints = cat(2, worldPoints, ones(size(worldPoints,1),1)*147);
%The 4 reference points given in ABB_IRB120_Setup_Data.txt are:
% [T2,T1,T3,T4]
%W_Ref_Points = [ 175,-520,147; 175,0,147; 175,520,147;548.6,0,147];
%in 2D
%The calibration points should return these values
%W_Ref_Points = [ 175,-520; 175,0; 175,520;548.6,0];

%These image points are manually chosen using:
Original = undistortImage(imread('blank_image2.jpg'),cameraParams);
 %imshow(Original);
 %ManualimagePoints = ginput(1);
%%
%Use this to convert image path co-ords to the robot from coords
%needed for the simulation:

load('ImagePathData.mat');
ManualimagePoints = TurnWayPoints;

%%
%Map image points to world coordinates in the X-Y plane.

newWorldPoints = zeros(size(ManualimagePoints));
%Project the image points into the world frame:
%camera coordinates = world coordinates * Rotation matrix + translation
%vector : [x y z] = [X Y Z]R + t
for count = 1 : size(ManualimagePoints,1)
    %Saving the coordinates in the robot frame
    newWorldPoints(count,:) = pointsToWorld(cameraParams,R,t,ManualimagePoints(count,:));
end
%newWorldPoints
newWorldPoints(:,[1,2])=newWorldPoints(:,[2,1]) 
worldPoints(:,[1,2])=worldPoints(:,[2,1]); 
% Image Frame
figure(2)
imshow(I);
hold on;
plot(imagePoints(:,1),imagePoints(:,2),'+r');
plot(ManualimagePoints(:,1),ManualimagePoints(:,2),'+b');
title('Image Coordinate Frame');
axis on;
hold off;

% Robot Frame
figure(3)
hold on;
plot(worldPoints(:,1),worldPoints(:,2),'+r');
plot(newWorldPoints(:,1),newWorldPoints(:,2),'+b');
title('Robot Coordinate Frame')
view([0 -90]);
hold off;
[C_Angle,C_Position] = estimateWorldCameraPose(imagePoints,worldPoints, cameraParams);
save('CalibrationData.mat');